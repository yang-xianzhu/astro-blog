---
title: HTTP
description: HTTP
layout: ../../../layouts/MainLayout.astro
---

#### 1、常见状态码

`3开头`：重定向

301:永久重定向

304:协商缓存  // 强缓存

`4开头`

400：请求参数错误

401: 没有权限（资源访问权限）

403：没有权限(token失效)

404: 地址找不到

405:用户在Request-Line字段定义的方法不允许

`5开头`：服务端问题

500：服务器产生内部错误

501：服务器不支持请求的函数

502：服务器暂时不可用，有时是为了防止发生系统过载

503：服务器过载或停止维修

504：关口过载，服务器使用另外一个关口或服务来响应用户，等待时间设定值较长

505：服务器不支持或拒绝请求头中指定的HTTP版本

#### 2、http的理解

HTTP：协议是超文本传输协议，是客户端浏览器或其他程序"请求"与Web服务器响应之间的应用层通信协议

HTTPS：主要是由HTTP+SSL构建的可进行加密传输、身份认证的一种安全通信通道。

#### 3、http与https的区别

- `https` 协议需要到CA申请证书，一般免费证书较小，因而需要一定的费用。
- `http` 是超文本传输协议，信息是明文传输的，https则是具有安全性的ssl加密传输协议。
- `http` 和 `https` 使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。
- `http` 的连接很简单，是无状态的：https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### 4、三次握手和四次挥手

三次握手是网络客户端跟网络服务器之间建立连接，并进行通信的过程。相当于客户端和服务器之间你来我往的三个步骤

1. 第一次握手是建立连接，客户端发送连接 请求报文，并传送规定的数据包
2. 第二次握手是服务器端表示接收到连接请求报文，并回传规定的数据包
3. 第三次握手是客户端接收到服务器回传的数据包后，给服务器端再次发送数据包。这样就完成了客户端跟服务器的连接和数据传送

#### 四次挥手表示当前这次连接请求已经结束，要断开这次连接

1. 第一次挥手是客户端对服务器发起断开请求
2. 第二次挥手是服务器表示接收到这次断开请求
3. 第三次挥手是服务器表示已经断开连接
4. 第四次挥手是客户端断开连接


```js
// 清理npm缓存
npm cache clean -f
// 安装scss
npm i sass sass-loader dart-sass

// .env.devalopment  开发环境会执行该文件
// .env.production   上线环境会执行该文件

vue.config.js文件下
module.exports = {
 publicPath：'/'  //   /是绝对路径  ./是相对路径 
}
```

- 对于对象后添加的属性，是丢失响应式的，vue监听不到的，但vue提供了api，this.$set/Vue.set，原因是Object.defineProperty的缺陷，对于数组，通过下标修改某个元素也是侦听不到的
- Object.defineProperty做数据劫持是给数据添加getters setters，如果是深结构的数据需要递归深层次遍历添加get set，初始化的时候性能损耗也比较大



#### 什么是跨域？怎么解决跨域？

- 跨域是浏览器为了安全考虑，设置的一个安全策略，`域名`、`端口号`、`协议`有一个不同，都违反了浏览器的同源策略，又称为跨域。
- 解决办法:
  - 利用jsonp，缺点是只支持`get请求`，不支持post请求
  - cors：前端配合后端解决
  - 利用iframe标签：document.domain+iframe的设置
  - 利用基于webpack构建的cli工具配置反向代理：配置proxy，`原理：`是先搭建一个代理服务器，通过代理服务器去访问另一个服务器，然后代理服务器拿到数据后再发送给浏览器，因为同源策略是浏览器与服务器之间的，而服务器与服务器是没有跨域的
  - 使用HTML5 postMessage

#### 强缓存和协商缓存

- 强缓存：不会发送请求到服务器，而是直接从缓存中取
- `http状态码`:200

> 服务端通过设置`Expires`和`Cache-Control`来实现

`Cache-Control`可以组合使用多个指令：

| 指令         | 作用                                                     |
| ------------ | -------------------------------------------------------- |
| public       | 表示响应可以被客户端和代理服务器缓存                     |
| private      | 表示响应只可以被客户端缓存                               |
| max-age=30   | 缓存30秒后过期，需要重新请求                             |
| s-maxage=30  | 覆盖max-age,作用一样，只在代理服务器中生效               |
| no-store     | 不缓存任何响应                                           |
| no-cache     | 资源被缓存，但是立即失效，下次会发起请求验证资源是否过期 |
| max-stale=30 | 30秒内，即使缓存过期，也会使用该缓存                     |
| min-fresh=30 | 希望在30秒内获取最新的响应                               |

- 协商缓存：会发送请求到服务器，通过服务器来告知缓存是否可用
- `http状态码`: 304

> 协商缓存表示如果缓存过期，那么就需要重新发起请求验证资源是否更新，可通过设置HTTP Header的last-modified和ETag来实现



#### 浏览器输入url回车后都发生了什么

1. 通过DNS域名解析出真实的服务器id地址
2. 查找缓存  ===> 浏览器 = 本地 = 路由器
3. 浏览器与目标服务器`建立TCP连接`
4. 浏览器通过http协议发送请求
5. 服务器处理请求
6. 服务器发出一个HTML响应
7. 释放/断开TCP连接
8. 浏览器显示页面
9. 浏览器发送获取嵌入在HTML中的其他内容

#### Cookie

特点：

- `有安全问题`，如果被拦截，就可以获取Session所有信息，然后将Cookie转发就能达到目的。
- 每个域名下的Cookie不能超过`20个`，大小不能超过`4kb`
- Cookie在请求新页面的时候都会发送过去
- Cookie创建成功名称就不能修改
- 跨域名不能共享Cookie

应用场景：

- 最常见的就是Cookie和Session结合使用，将SessionId存储到Cookie中，每次请求都会带上这个SessionId，这样服务器就知道是谁发起的请求
- 可以用来统计页面的点击次数

Cookie都有哪些字段：

- `Name`、`Size`顾名思义
- `value`:保存用户登录状态，应该将该值进行`加密`，`不能使用明文`
- `path`:可以访问此Cookie的路径，比如juejin.cn/editor，只有/editor这个路径下的才可以读取Cookie
- `httpOnly`：表示禁止通过JS访问Cookie，减少XSS攻击
- `secire`：只能在htttps请求携带
- `samesite`：规定浏览器不能在跨域中携带Cookie减少CSRF攻击
- `domain`:域名，跨域或者cookie的白名单，允许一个子域获取或操作父域的cookie，实现单点登录的话会非常有用。
- `Expires`/`Max-size`:指定时间或秒数的过期时间，没设置的话就和`session`一样关闭浏览器就失效。

#### XSS攻击

XSS攻击是一个`代码注入攻击`，通过恶意注入脚本在浏览器运行，然后盗取用户信息。

**造成XSS攻击其实本质还是因为网站没有过滤恶意代码，与正常代码混在一起之后，浏览器没有方法分辨哪些是可信的，然后导致恶意代码也被执行**，然后就可能导致一下情况：

- 页面数据或用户信息被窃取，如DOM、Cookie、localstorage
- 修改DOM，比如伪造登录窗口或在页面生成浮窗广告
- 监听用户行为，比如在登录或银行等站点用addEventListener监听键盘事件，窃取账号密码等信息
- 流量被劫持向其他网站

XSS攻击有三种类型：`存储型`、`反射型`、`DOM型`

- `存储型`：是在有发帖评论等带有数据保存功能的网站的input、textarea将恶意代码提交到网站数据库中，如`<script src="http://恶意网站"></script>`，然后比如在显示评论的页面就会从数据获取，并直接执行这个script标签里的恶意代码
- `反射型`:是攻击者将恶意JS脚本作为用户发送给网站请求的一部分,然后网站又把恶意脚本返回给用户,这时候就会在页面中被执行,比如打开包含带恶意脚本的链接,当打开后会向服务器请求后,服务器会获取URL中的数据然后拼接在HTML上返回,然后执行.它和存储型不同的是不会存储在服务器里
- `基于DOM型`:就是攻击通过一些劫持手段,在页面资源传输过程中劫持并修改页面的数据,插入恶意代码

防范XSS攻击的方法:

- 就是对输入框的内容进行`过滤`或转义符进行`转码`
- 使用`CSP`,就是`白名单`,告诉浏览器哪些外部资源可以加载执行,让即使插入进来恶意代码的也不会执行.或者可以向哪些第三方站点提交数据,开启白名单的方式有两种:
  - 使用meta标签 `<mete http-equiv="Content-Security-Policy"`
  - 设置http头部的`Content-Security-Policy`
- 对一些敏感信息进行保护,在`Cookie`信息中添加`httpOnly`,告诉浏览器在保存Cookie,并且不要对客户端脚本开放访问权限,然后就不能通过document.cookie获取cookie了.
- 使用`验证码`,避免脚本伪装成用户执行一些操作

#### HTTP 和 HTTPS协议的区别？

- `https`协议需要CA证书，费用较高，而`http`协议不需要
- `http`协议是超文本传输协议，信息是明文传输的，`https`则是具有较高的安全性，是`密文`传输的
- 使用不同的连接方式，端口也不同，`http`协议端口是80，`https`协议端口是443
- `http`协议连接很简单，是无状态的，`https`协议是具有`SSL`和`http`协议构建的可进行加密传输、身份认证的网络协议，比`HTTP`更加安全

#### webpack的基本功能

- 代码转化：如TypeScript编译成JavaScript、scss编译成css等
- 文件优化：压缩javascript、css、html代码，压缩合并图片等
- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
- 模块合并：在采用模块化的项目有很多模块的文件，需要构建功能把模块分类合并成一个文件
- 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器
- 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过
- 自动分布：更新完代码后，自动构建出线上发布代码并传输给发布系统

#### json.stringify的缺点

- 如果是时间对象，stringify后会变成一个时间字符串，不能使用时间对象的方法
- 如果对象里面的属性的值是undefined，或者是方法的话会丢失

#### 怎么解决白屏问题

- 骨架屏
- loading
- 首屏时间较长，如果 `SPA` 单页面可以使用路由懒加载，减少首屏时间。