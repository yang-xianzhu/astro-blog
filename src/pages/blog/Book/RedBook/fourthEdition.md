---
title: JavaScript高级程序设计
description: books
layout: ../../../../layouts/MainLayout.astro
---

### 函数

##### 尾调用优化

- 简介：ECMAScript规范新增了一项内存管理优化机制，让javascript引擎在满足条件时可以重用栈帧。
- 需要条件：
  - 代码在严格模式下执行；
  - 外部函数的返回值是对尾调用函数的调用；
  - 尾调用函数返回后不需要执行额外的逻辑；
  - 尾调用函数不是引用外部函数作用域中自由变量的闭包；

> 之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用f.arguments和f.caller,而它们都会引用外部函数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求必须在严格模式下有效，以防止引用这些属性。



##### 闭包

1. 简介：匿名函数经常被误认为是闭包（closure）。`闭包`指的是那些引用了另外一个函数作用域中变量的函数，通常是在嵌套函数中实现。

> 注意：使用不当容易产生内存泄漏。产生原因：错误引用该变量，导致引用一直存在，垃圾回收机制一直没回收。



##### 立即调用的函数表达式

​		立即调用的匿名函数又被称作`立即调用的函数表达式` （IIFE，Immediately Invoked Function Expressopn）。它类似函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟着第一组括号后面的第二组括号就会立即调用前面的函数表达式。

```js
(function (){
  // 块级作用域
})()
```

​		在es6及以前，为了防止变量定义外泄，IIFE是个非常有效的方式。这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，其作用域链就可以被销毁。

​		在es6之后，IIFE就没有那么必要了，因为块级作用域中的变量无须IIFE就可以实现同样的隔离。

```js
// 内嵌块级作用域
{
  let i;
  for(i=0;i < count; i++){
    console.log(i)
  }
}
console.log(i)  // 抛出错误！

// 循环的块级作用域
for(let i = 0;i < count; i++){
  console.log(i)
}
console.log(i)  // 抛出错误！

// 说明IIFE用途的一个实际的例子，就是可以用它锁定参数值。比如：
const divs = document.querySelectorAll('div')

// 达不到目的
for(var i = 0; i< divs.length;i++){
  divs[i].addEventListener('click',function(){
    console.log(i)
  })
}
```

这里使用 `var` 关键字声明了循环迭代变量i，但这个变量并不会被限制for循环的块级作用域内。因此，渲染到页面上之后，点击每个div都会弹出元素总数。这是因为在执行淡季处理程序时，迭代变量的值已经上循环结束时的最终值了，即元素的个数。而且，这个变量存在于循环体外部，随时可以被访问。这里也可以用到 `IIFE` 解决。



### DOM

细节：

- DOM操作在javascript代码中代价是比较高的，NodeList对象尤其需要注意。NodeList对象是`"实时更新"`的，这意味着每次访问它一次都要执行一次查询。考虑到这些问题，实践中要尽量减少DOM操作数量。
- MutaionObserver是为代替性能不好的MutaionEvent而问世的。使用它可以有效精准监控DOM变化，而且api相对简单。



### 动画与Canvas图形

- 虽然使用setInterval()的定时动画比使用多个setTimeout()实现循环效率更高，但也不是没有问题。无论是setInterval()还是setTimeout()都是`不能保证时间精度`的。作为第二个参数的延时只能保证何时会把代码添加到浏览器的`任务队列`，不能保证添加到任务队列就会立即执行。如果队列前面还有其他任务，那么就要等那些任务执行完毕再执行。简单来说，这里毫秒延时并不是何时这些代码就会执行，而只是说到了这个时间就会把回调添加到任务队列。如果添加到队列后，主线程还在被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。

> 解决方法：使用requestAnimationFrame方法


### 网络请求与远程资源

##### 跨源资源共享

通过 `XHR` 进行ajax通信的一个主要限制是 `跨源安全策略`。默认情况下，XHR只能访问与发起请求页面在同一个域内的资源。

- ##### 预检请求

  - 简介：COES通过一种叫 `预检请求` 的服务器验证机制，允许使用自定义头部、除了GET和POST之外的方法，以及不同请求体内容类型。在要发送涉及上述某种高级选项的请求时，会先向服务器发送一个"预检"请求。这个请求使用options方法发送并包含一下头部。
    - Origin：与简单请求相同。
    - Access-Control-Request-Method：请求希望使用的方法。
    - Access-Control-Request-Headers：（可选）要使用的逗号分隔的自定义头部列表。

##### 替代性跨源技术

- ##### 图片探测

  - 简介：图片探测是利用 `<img>` 标签实现跨域通信的最早的一种技术。任何页面都可以跨域加载图片而不必担心限制，因此这也是在线广告追踪的主要方式。可以动态创建图片，任何通过它们的 `onload` 和 `onerror` 事件处理程序得知何时收到响应。
  - 图片探测是与服务器之间 `简单` 、`跨域` 、`单向` 的通信。

##### Fetch API

- 简介：Fetch API能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在Web工作线程等现代Web工具中使用。XMLHttpRequest可以选择异步，而Fetch API则必须是异步。Fetch API 本身是使用javascript请求资源等优秀工具，同时这个API也能够应用在服务线程（service worker） 中，提供拦截、重定向和修改通过fetch（）生成的请求接口。

##### Beacon API

- 简介：为了把尽量多的页面信息传到服务器，很多分析工具需要在页面生命周期中尽量晚的时候向服务器发送遥测或分析数据。因此，理想情况下是通过浏览器的 `unload` 事件发送网络请求。

> 在unload事件处理程序中创建的任何的异步请求都会被浏览器取消。

##### Web Socket

- 简介：

  ​Web Socket（套接字）的目标是通过一个长时连接实现与服务器 `全双工` 、`双向` 的通信。javacript中创建Web Socket时，一个HTTP请求会发送到服务器以初始化连接。

  ​因为Web Socket使用了自定义协议，所以URL方案（scheme）稍有变化：不能再使用 `http://` 或 `https://`，而要使用 `ws://` 或 `wss://`。前者是不安全的连接，后者是安全连接。 

  ​使用自定义协议而非HTTP协议的好处是，客户端与服务端之间可以发送非常少的数据，不会对HTTP造成任何负担。使用更少的数据包让 Web Socket 非常适合**带宽**和**延迟**问题比较明显的移动应用。使用自定义协议的缺点是，定义协议的时间比定义Java script API要长。

- API

​		要创建一个Web Socket，就要实例化一个 `WebSocket`  对象并传入提供连接的URL：

```js
const socket = new WebSocket('绝对路径的url地址');
```

​		注意，必须给WebSocket构造函数传入一个绝对URL。同源策略不适用于Web Socket，因此可以打开到任意站点的连接。至于是否与来自特定源的页面通信，则完全取决于服务器。（在**握手**阶段就可以确定请求来自哪里）

​		WebSocket.OPENING(0)：连接正在建立。

​		WebSocket.OPEN(1)：连接已经建立。

​		WebSocket.CLOSING(2)：连接正在关闭。

​		WebSocket.CLOSE(3)：连接已关闭。

> 任何时候都可以调用close()方法关闭WebSocket的连接。
>
> socket.close()

- 发送和接收数据

​		服务器向客户端发送消息时，WebSocket对象上会触发**message**事件。

```js
socket.onmessage = function (event) {
  const data = event.data
}
```

- 其他事件

> WebSocket对象不支持DOM Level2事件侦听器，因此需要使用DOM Level0风格的事件处理程序来侦听这些事件。

```js
const socket = new WebSocket('url')

socket.onopen = function (){
  ...
}
 
socket.onerror = function (){
  ...
}
  
socket.onclose = function (){
  ...
}
```

在这些事件中只有**close**事件的event对象有额外信息。这个对象有三个属性：

- wasClean：是一个布尔值，表示连接是否干净地关闭；
- code：是一个来自服务器的数值状态码；
- reason：是一个字符串，包含服务器发来的信息。

##### 安全

​		在未授权系统可以访问某个资源时，可以将其视为**跨站点请求伪造**（CORF）攻击。未授权系统会按照处理请求的服务器的要求伪装自己。Ajax应用程序，无论大小，都会受到CSRF攻击的影响，包括无害的漏洞验证攻击和恶意的数据盗窃或数据破坏攻击。

​		关于安全防护Ajax相关URL的一般理论认为，需要验证请求发送者拥有对资源的访问权限，可以通过一下方式实现：

- 要求通过SSL访问能够被Ajax访问的资源。
- 要求每个请求都发送一个按约定算法计算好的令牌（token）。

​	注意：以下手段对防护CSRF攻击是无效的。

- 要求POST而非GET请求（很容易修改请求方式）
- 使用来源URL验证来源（来源URL很容易被修改）
- 基于cookie验证（同样很容易被伪造）

​	

##### 小结

- XHR的一个主要限制是同源策略，即通信只能在**相同域名**、**相同端口**、**相同协议**的前提下完成。
- 图片探测和JSONP是另外两种跨域通信技术，但没有CORS那么可靠。
- Fetch API是作为对XHR对象的一种端到端的替代方案而提出的。这个API提供了优秀基于期约（promise）的结构、更直观的接口，以及对 Stream API的最好支持。

### 客户端存储

1. ##### cookie：

​		HTTP cookie 通常也叫做cookie。最初用于在客户端存储会话信息。这个规范要求服务器在响应HTTP请求时，通过发送Set-CookieHTTP头部包含会话信息。

​		浏览器会存储这些会话信息，并在之后的每次请求都会通过HTTP头部cookie再将它们吗发回服务器。

- 限制

​		cookie是与特定域绑定的。设置cookie后，它会与请求一起发送到创建它的域。这个限制能保证cookie中存储的信息只对被认可的接收者开放，不被其他域访问。

​		因为cookie存储在客户端机器上，所以为了保证它不会被恶意使用，浏览器会施加限制。，同时cookie也不会占用太多磁盘空间。

通常，只要遵守以下大致的限制，就不会在任何浏览器碰到问题。

- 不超过**300**个cookie；
- 每个cookie 不超过**4096**字节；
- 每个域不超过**20**个cookie；
- 每个域不超过**81920**字节；

每个域能设置的cookie总数也是受限的，但不同浏览器的限制不同。

- 最新版IE和Edge限制每个域不超过**50**个cookie；
- 最新版Firefox限制每个域不超过**150**个cookie；
- 最新版Opera限制每个域不超过**180**个cookie；
- Safari和Chrome对每个域的cookie数没有硬性控制；

> 注意：
>
> 这个大小限制适用于一个域的所有cookie，而不是单个cookie。
>
> 如果创建的cookie超过最大限制，则该cookie会被静默删除。

- 使用cookie的注意事项

​		因为所有cookie都会作为请求头部由浏览器发送给服务器，所以在cookie中保存大量信息可能会影响特定域浏览器请求的性能。保存的cookie越大，请求完成的时间就会越长。既使浏览器对cookie大小有限制，最好还是尽可能值通过cookie保存必要信息，以避免性能问题。

2. Web Storage

​		Web Storage 最早是网页超文本应用技术工作组在 Web Applications1.0规范中提出的。Web Storage的目的是解决通过客户端存储不需要频繁发送回服务器的数据时使用cookie的问题。

​		Web Storage规范有两个目标：

- 提供在cookie之外的存储会话数据的途径。
- 提供跨会话持久化存储大量数据的机制。

​		Web Storage 的localStorage 和 sessionStorage。localStorage是永久存储机制，sessionStorage 是跨会话的存储机制。

> 注意：Web Storage 第一版曾使用过 globalStorage，不过目前globalStorage已废弃了。

​		所有现代浏览器在实现存储写入时都使用了**同步阻塞**方式，因此数据会被立即提交到存储中。具体API到实现可能不会立即把数据写入磁盘（而是使用某种不同物理存储），但这个区别在JavaScript层面是不可见的。通过Web Storage写入的任何数据都可以立即被读取。

​		老版本的IE以异步方式实现的数据写入，因此给数据赋值的时间和数据写入磁盘的时间可能存在延迟。

- 存储事件

每当Storage对象发生变化时，都会在文档上触发**storage**事件。使用属性或者setItem（）设置值，使用delete或removeItem（）删除值，以及每次调用clear（）时都会触发这个事件。

1. domain：存储变化对应的域。
2. key：被设置或删除的键。
3. newValue：键被设置的新值，若键被删除则为null。
4. oldValue：键变化之前的值。

```js
window.addEventListener('storage', (event)=>{
  // ...
})
```

对于sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但storage事件不会区分这两者。

- 限制

不同浏览器给 localStorage 和 sessionStorage 设置了不同的空间限制，但大多数会限制每个源5MB。

3. IndexedDB

Indexed Database API简称**IndexedDB**，是浏览器中存储结构化数据的一个方案。

IndexedDB的设计几乎完全是**异步**的。

- 数据库

与传统数据库最大的区别在于，IndexedDB使用对象存储而不是表格保存数据。

4. 限制

IndexedDB数据库是与页面源（协议、域名、端口号）绑定的，因此信息不能跨域共享。

### 模块

1. 理解模块模式

将代码拆分成独立的快，然后再把这些块连接起来可以通过模块模式来实现。

- 模块标识符

​	模块标识符书所有模块系统通用的概念。模块系统本质上是键/值实体，其中每个模块都有个可用用用的标识符。

- 模块依赖

​	模块依赖的核心是管理依赖。指定依赖的模块与周围的环境会达成一种契约。本地模块向模块系统声明一种外部模块（依赖），这些外部模块对于当前模块正常运行时必需的。模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。

- 模块加载

​	加载模块的概念派生自依赖契约。当一个外部被指定为依赖时，本地模块期望在执行它时，依赖已准备好并初始化。

​	在浏览器中，加载模块涉及几个步骤。加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回，收到模块代码后，浏览器必须确定刚收到的模块是否也有依赖。然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成，只有整个依赖图都加载完成，才可以执行入口模块。

- 入口

​	互相依赖的模块必须指定一个模块作为入口，这也是代码执行的**起点**。

![image-20221011230940545](/红宝书-模块-01.png)

​	图中箭头表示依赖方向：模块A依赖模块B和模块C，模块B依赖模块D和模块E，模块C依赖模块E。因为模块必须在依赖加载完成才能被加载，所以这个应用程序的入口模块A必须在应用程序的其他部分加载后才能执行。

​	模块加载是**"阻塞"**的。这意味着前置操作前必须完成才能后置操作。

- 动态依赖

​	动态依赖可以支持更复杂的依赖关系，但代价是增加了对模块进行静态分析的难度。

- 静态分析

​	更复杂的模块行为，例如动态依赖，会导致静态分析更困难。

2. 使用ES6之前的模块加载器
   1. CommonJS
      - CommonJS规范概述了同步声明依赖的模块定义。
      - CommonJS模块语法不能直接在浏览器中直接运行。
      - 无论一个模块在**require()**引用多少次，模块永远都是**单例**的。
      - 模块**第一次加载后会被缓存**，后续加载会取得缓存的模块。

- 模块加载

​	完全支持ECMAScript6模块的浏览器可以从顶级模块加载器加载整个依赖图，且是**异步**的。

- 模块行为

​	ECMAScript6模块借用了CommonJS 和 AMD 的很多优秀特性。

 	1.	模块代码只在加载后执行。
 	2.	模块只能加载一次。
 	3.	模块是单例的。
 	4.	模块可以定义公共接口，其他模块可以基于这个公共接口观察和交互。
 	5.	模块可以请求加载其他模块。
 	6.	支持循环依赖。

ES6模块系统也增加了一些新行为。

1. ES6模块默认在严格模式下执行。
2. ES6模块不共享全局命名空间。
3. 模块顶级this的值是undefined（常规脚本中是window）。
4. 模块中的var声明不会添加到window对象。
5. ES6模块是异步加载和执行的。

- 模块导入

​	与**export**类似，import必须出现在模块的顶级。

​	如果在浏览器中通过标识符原生加载模块，则文件必须带有 **js**扩展名，不然可能无法正确解析。

​	不是必须通过到处的成员才能导入模块。如果不需要模块的特定导入，但仍然想加载和执行模块以利用其**副作用**，可以通过路径加载它。

```js
import './test.js'  // 执行test文件的副作用
```

​	导入对模块而言是**只读的**。实际上相当于const声明对变量。在使用*执行批量导入时，赋值给别名对命名到处就好像使用Object.freeze()冻结过一样。直接修改导出的值是不可能的，但可以修改导出对象的属性。

```js
import { default as foo } from './foo.js'
// 等效于如下
import foo from './foo.js'
```

- 向后兼容

	浏览器在调用`<script>`标签上无法识别等type属性时会拒绝执行其内容。对于不支持模块的浏览器，这意味着`<script type="module">`不会被执行。


### 最佳实践

1. ##### 可维护性

   - 什么是可维护性的代码
     - **容易理解**：无须求助原始开发者，任何人一看代码就知道它是干什么的，以及它怎么实现的。
     - **符合常识**：代码中的一切都显得顺利成章，无论操作有多么复杂。
     - **容易适配**：即使数据发生变化也不用完全重写。
     - **容易扩展**：代码架构经过认真设计，支持未来扩展核心功能。
     - **容易调试**：出问题时，代码可以给出明确的信息，通过它能直接定位问题。
   - 编码规范
     - 可读性
       - 函数和方法：每个函数和方法都应该有注释来描述其用途。
       - 大型代码块：多行代码但用于完成**单一任务**的，应该在前面给出注释，把要完成的任务写清楚。
       - 复杂的算法：如果使用了独特的方法解决问题，要通过注释解释清楚。这样不仅可以帮助别人查看代码，也可以帮助自己今后查看代码。
       - 使用黑科技：由于浏览器之间的差异，Java script代码中通常包含一些黑科技，不要假设其他人一看就能明白某个黑科技是为了解决某个浏览器的什么问题。如果某个浏览器不能使用正常方式达到目的，那要在注释里把黑科技的用于写出来。这样**避免别人误认为黑科技没有用于把它“修复”掉**，结果你已解决掉问题又会出现。
     - 松散耦合
   - 编码惯例
     - 尊重对象的所有权
       - 不要给实例或原型添加属性或方法
       - 不要重定义已有的方法

   > 最好的方法是永远不要修改不属于自己的对象，只有你自己创建的对象，包含自定义类型和对象字面量。

   - 创建包含需要功能的新对象，通过它与别人的对象交互。

   - 创建新自定义类型继承本来想要修改的类型，可以给自定义类型添加新功能。

     - 不声明全局变量

     与尊重对象所有权密切相关的是尽可能的不声明全局变量和函数。

   - 不要比较**null**

     > 检查值的类型就要真的检查类型，而不是检查它不能是什么。

     - 如果值应该是**引用类型**，则可以使用**instanceof**操作符检查其构造函数。
     - 如果值应该是**简单类型**，则可以使用**typeof**操作符检查其类型。
     - 如果希望值是有特定方法名的对象，则使用**typeof操作符确保对象上存在给定名字的方法。

     > 代码中比较null的地方越少，就越容易明确类型检查的目的，从而消除不必要的错误。

   - 使用常量

   依赖常量的目标是从应用程序逻辑中分离数据，以便修改数据时不会引发错误。

   1. **重复出现的值**：任何使用超过一次的值都应该提取到常量中，这样可以消除一个值改了而另外一个值没改造成的错误。这里也包含**CSS的类名**、**清除本地存储的key**等。
   2. **用户界面字符串**：任何会显示给用户的字符串的一个提取出来，以方便**实现国际化**。
   3. **URL**：Web应用程序中资源的地址经常会发生变化，因此建议把所有的URL集中放到一个地方管理。
   4. **任何可能变化的值**：任何时候，只要在代码中使用字面量，就问问自己这个值将来是否会变。如果答案是“是”，那么就应该把它提取到常量中。

   > 使用常量是企业级Java script开发到重要方式，因为它可以让代码更容易维护，同时可以让代码免受数据变化的影响。

2. ##### 性能

JavaScript一开始就是一门解释型语言，因此执行速度比编译语言要慢一些。

> 任何可以缩短遍历作用域链时间拆措施都能提升代码性能。

- 作用域意识

  - 避免全局查找

  改进代码性能非常重要的一件事，可能就是要提防**全局查询**。全局变量和函数相比于局部值始终是最费时间的，因为想要经历作用域链查找。

  ```js
  function updateUI(){
    const imgs = document.getElementsByTagName('img')
    const _len = imgs.length
    for(let i=0;i<_len;++i){
      // ...
    }
  }
  ```

  > 通过在局部作用域中保存docuemnt对象，能够明显提升这个函数的性能，因为只需要作用域查找一个指向document对象的局部变量。

  > 只要函数中引用超过两次的全局对象，就应该把这个对象保存为一个局部变量。

  - 不使用with语句

  实际编码时很少需要使用**with**语句的情况，因为它的主要用途是节省一点代码。大多数情况下，使用**局部变量**可以实现同样的效果，无须增加新作用域。

- 选择正确的方法

​	影响性能的因素通常涉及到算法和解决问题的方法。

1. 避免不必要的属性查找

​	最简单同时也最快的算法可以表示为**常量值**或**O(1)**。

|  表示法  |  名称  |                             说明                             |
| :------: | :----: | :----------------------------------------------------------: |
|   O(1)   |  常量  |  无论多少值。执行时间都不会变。表示简单值和保存在变量中的值  |
| O(logn)  |  对数  | 执行时间随着值的增加而增加。但算法完成不需要读取每个值。例子：二分查找 |
|   O(n)   |  线性  |     执行时间与值的数量直接相关。例子：迭代数组的所有元素     |
| O(n平方) | 二次方 | 执行时间随着值的增加而增加，而且每个值至少读取n次。例子：插入排序 |

常量值O(1)，指字面量和保存在变量中的值，表示读取常量值所需的时间不会因值的多少而变化。读取常量值是效率极高的操作。因此非常快。

> 在Java script中访问数组元素也是O(1)操作，与简单的变量查找一样。

使用变量和数组相比访问对象属性效率更高，**访问对象属性**的算法复杂度是**O(n)**。访问对象的每个属性都比访问变量和数组花费时间要长，因为查找属性名要**查找原型链**。

> 通过数代码中的点号数量，就可以知道有几次属性查找了。

只要使用某个object属性超过一次，就应该将其保存在局部变量中。第一次仍然要使用算法复杂度为O(n)去查找，但后续每次访问属性就都是O(1),这样做就是质的提升了。

2. 优化循环

   1. **简化终止条件**：因为每次循环都会计算终止条件，所以它应该尽可能地快。这意味着要比慢属性查找或其他的O(n)操作。
   2. **简化循环体**：循环体是最花时间的部分，因此要尽可能优化。要确保其中不包含可以轻松转移到循环外的密集计算。
   3. **使用后测试循环**：最常用的循环就是`for`、`while`循环。这两种循环都属于**先测试循环**，`do-while`就是后测试循环，避免对终止条件初始评估，因此会更快。

   ```js
   注意：在旧版浏览器中，从循环体迭代器的最大值开始递减至0点效率更高。之所以这样更快，是因为javascript引擎用于检查循环分支条件的指令数更少。在现代浏览器中，正序还是倒序不会有感知的性能差异。
   ```

   3. 展开循环

   如果循环次数是有限的，那么通常抛弃循环而直接多次调用函数会更快。

   > 如果不能提前预知循环的次数，那么或许可以使用一种叫做**达夫设备**的技术。
   >
   > 达夫设备的基本思路是以8的倍数作为迭代次数从而将循环展开为一系列语句。

   4. 避免重复解释

   很少有情况绝对要使用**eval()**，因此应该尽可能不使用它。

   5. 其他性能优化注意事项
      - **原生方法很快**：应该尽可能的使用原生方法，而不是使用Java script写的方法。原生方法是使用**C**或**C++**等编译语言写的，因此比javascript写的方法要快很多。
      - **switch语句很快**：如果代码中有复杂的`if-else`，将其转换成`switch`语句可以变得更快。然后，通过重新组织分支，把最有可能的放到最前面，不太可能的放到后面，可以进一步提升性能。
      - 位操作很快：在执行数学运算操作时，位操作一定比任何布尔值或数值计算更快。

- 语句最少化

javascript代码中语句的数量影响操作执行的速度。一条可以执行多个操作的语句，比多条语句每个语句执行一个操作更快。那么优化的目标就是寻找可以合并的语句，以减少整个脚本的执行时间。

​	1.	多个变量声明

```js
const num =0;
const isshow = true;
const str = 'yxz'
// 可以转换为一下
const num =0,
      isShow = true,
      str = 'yxz'
```

  		2.	插入迭代性值
  		3.	使用数组和对象的字面量

尽可能的使用数组或对象字面量，减少不必要的语句。

- 优化DOM交互

 1. 实时更新最小化

    访问DOM时，只要访问的部分是显示页面的一部分，就是在执行**实时更新**操作。

 2. 使用innterHTML

​		原生DOM方法速度更快，因为该方法是在执行编译代码而非解释代码。

> 注意：使用innterHTML可以提升性能，但也会暴露巨大的XSS攻击面。无论何时使用它填充不受控的数据，都有可能被攻击者注入可执行代码。

 	3.	使用**事件委托**

​		事件委托利用事件冒泡。任何冒泡的事件都可以不在事件目标上，而在目标的任何元素上处理。

只要可能，就应该在**文档级**添加事件处理程序，因为在文档级可以处理整个页面的事件。事件委托还有一个好处就是，对于ul下后新增的li，利用事件委托也可以绑定事件。

4. 注意HTMLCollection

​		编写javascript代码时，关键是要记住，只要返回的**HTMLCollection**对象，就应该尽可能不访问它。

- 调用**getElementsByTagName()**
- 读取元素的**chidNodes**属性
- 读取元素的**attributes**属性
- 调用特殊的集合，如**document.form**、**document.images**等