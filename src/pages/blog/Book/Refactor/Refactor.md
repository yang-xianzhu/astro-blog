---
title: 重构
description: books
layout: ../../../../layouts/MainLayout.astro
---

## 重构

> 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。

**好代码的检验标准就是人们是否能够轻而易举地修改它。**

## 重构的原则

### 何谓重构

**重构**（名词）：对软件内部结构的一种调整，目的是在不改变软件可观擦行为的前提下，提高其可理解性，降低其修改成本。

**重构**（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

可观察行为，整体而言，经过重构之后的代码所做的事应该与重构之前大致一致。这个说法并非完全严格，因为：**重构之后的代码不一定与重构前行为完全一致。比如说，提炼函数会改变函数调用栈，因此程序的性能就会有所改变；改变函数声明和搬移函数等重构经常会改变模块的接口**。

### 两项帽子

`两项帽子`的比喻：**添加新功能**和**重构**。

添加新功能时，我们不应该修改既有代码，只管添加新功能。通过添加测试并让测试正常进行，我们可以衡量自己的工作进度。重构时我们就不能再添加功能，只管调整代码的结构。此时我们不应该添加任何测试（除非发现有先前遗漏的东西），只在绝对必要（用以处理接口变化）时才修改测试。

### 为何重构

#### 重构改进软件的设计

如果没有重构，程序的内部设计（或者叫架构）会逐渐腐败变质。当人们只为短期目的而修改代码时，他们经常没有完全理解架构的整体设计，于是代码逐渐失去了自己的结构。程序员越来越难通过阅读源码来理解原来的设计。代码结构的流失有累积效应。越难看出代码所代表的设计意图，就越难保护其设计，于是设计就腐败得越快。经常性重构有助于代码维持自己该有的形态。

完成同样一件事，**设计欠佳的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事，因此改进设计的一个重要的方向就是消除重复代码**。代码量减少并不会将使系统运行得更快，因为这对程序的资源占用几乎没有任何明显影响。然而代码量减少将使未来可能的程序修改动作容易得多。代码越多，做正确的修改就会越困难，因为有更多代码需要理解。比如我们在这里做了一点儿修改，系统却不如如期那样工作，因为我没有修改另一次--那里的代码做着几乎完全一样的事情，只是所处环境略有不同，消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本。

#### 重构使软件更容易理解

所谓程序设计，很大程度上就是与计算机对话，我编写代码告诉计算机做什么事，而它的响应就是按照我的指示精确行动。一言以蔽之，我所做的就是填补`我想要它做什么`和`我告诉它怎么做`之间的缝隙。编程的核心就在于`准确说出我想要的`。然而别忘了，除了计算机之外，源码还有其他读者：几个月之后可能会有另外一位程序员尝试读懂我的代码并对我的代码做一些修改。我们很容易忘记这位读者，但他才是最重要的。计算机是否多花几个时钟周期来编译，又有什么关系呢？如果一个程序员多花费一周时间来修改其段代码，这才要命。问题在于，当我们努力让程序运转的时候，我们不会想到未来出现的那个开发者。是的，我们应该改变一下开放节奏，让代码变得更易于理解。重构可以帮我让代码更易读。开始进行重构前，代码可以正常运行，但结构不够理想。在重构上花一点点时间，就可以让代码更好地表达自己的意图-更清晰地说出我想要做的。

#### 重构帮助找到 bug

#### 重构提高编程速度

### 何时重构

> 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。事不过三，三则重构。

#### 预备性重构：让添加新功能更容易

重构的最佳时机就在添加新功能之前。

#### 帮助理解的重构：使代码更易懂

一旦我们需要思考这段代码到底在做什么，就可以考虑能不能重构这段代码，令其一目了然。

重构带来的帮助不仅发生在将来—常常是立竿见影。我们会在一些小细节上使用重构来帮助理解代码，给一两个变量改名，让它们更清楚地表达意图，以方便理解，或是将一个长函数拆成几个小函数。

#### 捡垃圾式重构

重构的妙处就在于，每个小步骤都不会破坏代码—所以，有时一块垃圾在好几个月之后才终于清理干净，但即使每次清理并不完整，代码也不会被破坏。

#### 有计划的重构和见机行事的重构

预备性重构、帮助理解的重构、捡垃圾式重构—都是见机行事的：我们并不专门安排一段时间来重构，而是在添加功能或修复 bug 的同时顺便重构。

> 肮脏的代码必须重构，但漂亮的代码也需要很多重构。

长久以来，人们认为编写软件是一个累加的过程：要添加新功能，我们就应该增加新代码。但优秀的程序员知道，添加新功能最快的方法往往是先修改现有的代码，使新功能容易被加入。所以，软件永远不应该被视为**完成**。每当需要新功能时，软件就应该做出相应的改变。越是在已有代码中，这样的改变就显得越重要。

### 长期重构

大多数重构可以在几分钟—最多几小时一一完成。

如果想替换掉一个正在使用的库，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，替换下面的库就会容易得很多。

#### 复审代码时重构

代码复审对于编写清晰代码也很重要。我的代码也许对我自己来说很清晰，对他人则不然。这是无法避免的，因为要让开发者设身处地为那些不熟悉自己代码所作所为的人着想，实在太困难了。代码复审也让更多人有机会提出有用的建议。

重构可以帮助我们复审比如的代码。开始重构前我们可以先阅读代码，得到一定程度的理解，并提出一些建议。一旦想到一些点子，我们就可以考虑是否可以通过重构立即轻松地实现它们。如果可以，我们就应该动手。这样做了几次以后，我们可以更清楚地看到，当我的建议被实施以后，代码会是什么样。我们不必想象代码应该是什么样，我们可以真实看见。于是我们可以获得更高层次的认识。如果不进行重构，我们永远无法得到这样的认识。

重构还可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立刻实现。

至于如何在代码复审的过程中加入重构，这要取决于复审的形式。在常见的 pull request 模式下，复审者独立浏览代码，代码的作者不在旁边，此时进行重构效果并不好。如果代码的原作者在旁边会好很多，因为作者能提供关于代码的上下文信息，并浏览代码一边重构，体验是最佳的。这种工作方式很自然地导向**结对编程**：在编程的过程中持续不断进行代码复审。

#### 何时不应该重构

如果我看见一个凌乱的代码，并不需要修改它，那么我就不需要重构它。如果丑陋的代码能被隐藏在一个 API 之下，我就可以容忍它继续保持丑陋。只有当我需要理解其工作原理时，对其进行重构才有价值。

另一种情况是，如果重写比重构还容易，那就别重构了。这是一个困难的决定。如果不花一点儿时间尝试，往往很难真实了解重构一块代码的难度。决定到底应该重构还是重写，需要良好的判断力与丰富的经验。

## 代码的坏味道

### 神秘命名

整洁代码最重要的一环就是好的名字，所以我们应该深思熟虑如何给函数、模块、变量、类命名，使它们能清晰地表明自己的功能和用法。

然而，很遗憾，命名是编程中最难的两件事之一。正因为如此，改名可能是最常见的重构手法，包括改变函数声明（用于给函数改名）、变量改名、字段改名等。很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。

改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

### 重复代码

如果你在一个以上的地方看到相同的代码结构，那么可以肯定：设法将它们合二为一，程序会变得更好。一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。

最单纯的重复代码就是"同一个类的两个函数含有相同的表达式"。这时候你需要做的就是采用提炼函数提炼出重复的代码，然后让这两个地方都调用被提炼出来的那一段代码。如果重复代码只是相似而不是完全相同，请首先尝试用移动语句重组代码顺序，把相似的部分放到一起以便提炼。如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移来避免两个子类之间互相调用。
